import { NodeId, Entry, Event, EffectAbstract, Signal } from './elements';
export declare type ObservedEvents = Record<Event, Set<NodeId>>;
export declare type ObservedEventsArray = Record<Event, Array<NodeId>>;
export declare class NetworkModel {
    nodes: Set<NodeId>;
    observedEvents: ObservedEvents;
    cachedDiff: ObservedEvents | null;
    pendingEffects: Array<EffectAbstract & {
        node: NodeId;
    }>;
    ignoredPendingObservations: ObservedEvents;
    constructor(nodes: Array<NodeId>);
    consumeSignal(node: NodeId, signal: Signal): void;
    isConsistent(): boolean;
    numEventsAwaiting(): number;
    addNode(node: NodeId): void;
    removeNode(node: NodeId): void;
    /**
     * Produces a map that describes what needs to show up in observedEvents
     * before the network can be considered in a consistent state.
     * If the map is empty, we are consistent.
     */
    eventDiff(): ObservedEvents;
    eventDiffArray(): ObservedEventsArray;
    ignoredPendingObservationsArray(): ObservedEventsArray;
    ignorePending(): void;
    /**
     * Determine which nodes are validators for a particular Entry,
     * based on the action (which should have a reference to the entry)
     */
    validators: (event: string) => Set<string>;
}
export declare class FullSyncNetwork extends NetworkModel {
    validators: (entry: Entry) => Set<string>;
}
