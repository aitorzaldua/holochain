"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const _ = require("lodash");
const elements_1 = require("./elements");
const logger_1 = require("./logger");
class NetworkModel {
    // // a connectivity matrix representing every possible p2p connection
    // // the number represents additional latency to simulate. Negative numbers mean infinite latency.
    // connectionMatrix: Array<Array<number>>
    constructor(nodes) {
        /**
         * Determine which nodes are validators for a particular Entry,
         * based on the action (which should have a reference to the entry)
         */
        this.validators = (event) => {
            throw "abstract method not implemented";
        };
        this.nodes = new Set(nodes);
        this.observedEvents = {};
        this.pendingEffects = [];
        this.ignoredPendingObservations = {};
        this.cachedDiff = null;
    }
    consumeSignal(node, signal) {
        logger_1.default.silly("consumeSignal: %s, %j", node, signal);
        const { event, pending } = signal;
        this.cachedDiff = null;
        if (!this.observedEvents[event]) {
            this.observedEvents[event] = new Set();
        }
        this.observedEvents[event].add(node);
        this.pendingEffects = this.pendingEffects.concat(pending.map(p => _.assign({ node }, p)));
    }
    isConsistent() {
        return _.isEmpty(this.eventDiff());
    }
    numEventsAwaiting() {
        const diff = this.eventDiff();
        return _.sum(_.values(diff).map(ns => ns.size));
    }
    addNode(node) {
        this.cachedDiff = null;
        this.nodes.add(node);
    }
    removeNode(node) {
        this.cachedDiff = null;
        this.nodes.delete(node);
    }
    /**
     * Produces a map that describes what needs to show up in observedEvents
     * before the network can be considered in a consistent state.
     * If the map is empty, we are consistent.
     */
    eventDiff() {
        if (this.cachedDiff === null) {
            const frequencyPairs = this.pendingEffects.map(effect => {
                const { event, group, node } = effect;
                const observed = this.observedEvents[event] || new Set();
                const nodes = (group === elements_1.EffectGroup.Validators)
                    ? Array.from(this.validators(event))
                    : (group === elements_1.EffectGroup.Source)
                        ? [node]
                        : (() => { throw new Error(`Unrecognized group: ${group}`); })();
                // set difference (nodes - observed)
                const unresolved = nodes.filter(v => !observed.has(v));
                return [event, new Set(unresolved)];
            })
                .map(([event, unresolved]) => [event, setDifference(unresolved, this.ignoredPendingObservations[event] || new Set())])
                .filter(([x, unresolved]) => !_.isEmpty(unresolved));
            this.cachedDiff = _.fromPairs(frequencyPairs);
        }
        logger_1.default.debug('eventDiff: %o', this.cachedDiff);
        return _.cloneDeep(this.cachedDiff);
    }
    eventDiffArray() {
        return _.mapValues(this.eventDiff() || {}, (nodes) => Array.from(nodes));
    }
    ignoredPendingObservationsArray() {
        return _.mapValues(this.ignoredPendingObservations || {}, (nodes) => Array.from(nodes));
    }
    ignorePending() {
        _.mergeWith(this.ignoredPendingObservations, this.eventDiff(), setUnion);
        this.cachedDiff = null;
    }
}
exports.NetworkModel = NetworkModel;
class FullSyncNetwork extends NetworkModel {
    constructor() {
        super(...arguments);
        this.validators = (entry) => {
            // currently full-sync
            return _.cloneDeep(this.nodes);
        };
    }
}
exports.FullSyncNetwork = FullSyncNetwork;
// from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set
function setUnion(setA, setB) {
    let _union = new Set(setA);
    for (let elem of setB) {
        _union.add(elem);
    }
    return _union;
}
// from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set
function setDifference(setA, setB) {
    let _difference = new Set(setA);
    for (let elem of setB) {
        _difference.delete(elem);
    }
    return _difference;
}
//# sourceMappingURL=network.js.map