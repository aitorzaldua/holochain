"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const _ = require("lodash");
const logger_1 = require("./logger");
const callback_1 = require("./callback");
const DEFAULT_SOFT_TIMEOUT_MS = 5000;
const DEFAULT_HARD_TIMEOUT_MS = 12000;
class Waiter {
    constructor(networkModelClass, initialNetworks = {}, opts = {}) {
        this.completedObservations = [];
        this.callbacks = [];
        this.networkModelClass = networkModelClass;
        this.networks = _.cloneDeep(initialNetworks);
        this.timeoutSettings = {
            softDuration: opts.softTimeout || DEFAULT_SOFT_TIMEOUT_MS,
            hardDuration: opts.hardTimeout || DEFAULT_HARD_TIMEOUT_MS,
            strict: opts.strict || false
        };
    }
    addNode(networkName, nodeId) {
        if (this.networks[networkName]) {
            this.networks[networkName].addNode(nodeId);
        }
        else {
            this.networks[networkName] = new this.networkModelClass([nodeId]);
        }
    }
    removeNode(networkName, nodeId) {
        if (this.networks[networkName]) {
            this.networks[networkName].removeNode(nodeId);
        }
        // don't worry about removing networks once all nodes leave
    }
    totalEventsAwaiting() {
        return _.sum(_.values(this.networks).map(model => model.numEventsAwaiting()));
    }
    eventsAwaiting() {
        return _.mapValues(this.networks, model => model.eventDiff());
    }
    eventsAwaitingArray() {
        return _.mapValues(this.networks, model => model.eventDiffArray());
    }
    ignoreAllPending() {
        _.mapValues(this.networks, model => model.ignorePending());
    }
    registerCallback(cb) {
        logger_1.default.silly('REGISTERING callback with %i pending', this.totalEventsAwaiting());
        const timedCallback = new callback_1.TimedCallback(this, cb);
        if (this.totalEventsAwaiting() > 0) {
            // make it wait
            timedCallback.initTimers();
            this.callbacks.push(timedCallback);
        }
        else {
            // nothing to wait for
            cb.resolve(0);
        }
        return timedCallback;
    }
    handleObservation(o) {
        const pendingBefore = this._totalPendingByCallbackId();
        logger_1.default.silly("Handling observation: %j", o);
        this.networks[o.dna].consumeSignal(o.node, o.signal);
        this.completedObservations.push({
            observation: o,
            stats: { timestamp: Date.now() }
        });
        this._checkCompletion(pendingBefore);
    }
    _totalPendingByCallbackId() {
        return _.fromPairs(this.callbacks.map(tc => [
            tc.id,
            tc.totalPending()
        ]));
    }
    _checkCompletion(pendingBefore) {
        this.callbacks = this.callbacks.filter(tc => {
            const { id, cb: { resolve } } = tc;
            const pending = tc.totalPending();
            const completed = tc.isCompleted();
            const decreased = pending < pendingBefore[tc.id];
            if (completed) {
                tc.clearTimers();
                resolve(this.completedObservations.length - tc.numCompletedAtStart);
                logger_1.default.silly('resolved callback id: %s', id);
            }
            else if (decreased) {
                tc.setTimers();
            }
            return !completed;
        });
    }
}
exports.Waiter = Waiter;
//# sourceMappingURL=waiter.js.map