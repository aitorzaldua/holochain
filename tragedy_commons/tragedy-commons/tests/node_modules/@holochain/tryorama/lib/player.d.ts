/// <reference types="node" />
import { Conductor } from './conductor';
import { SpawnConductorFn, RawConductorConfig, InstallAgentsHapps, InstalledAgentHapps, InstallHapp, InstalledHapp } from './types';
import { AdminWebsocket, ListAppsRequest, InstallAppRequest, AppWebsocket, HoloHash, AppBundleSource, InstallAppBundleRequest, ListAppsResponse } from '@holochain/conductor-api';
import * as T from './types';
import { TunneledAdminClient, TunneledAppClient } from './trycp';
declare type ConstructorArgs = {
    scenarioUID: string;
    name: string;
    config: RawConductorConfig;
    adminInterfacePort?: number;
    onJoin: () => void;
    onLeave: () => void;
    onActivity: () => void;
    spawnConductor: SpawnConductorFn;
};
/**
 * Representation of a Conductor user.
 * A Player is essentially a wrapper around a conductor config that was generated,
 * and the possible reference to a conductor which is running based on that config.
 * The Player can spawn or kill a conductor based on the generated config.
 * Players are the main interface for writing scenarios.
 */
export declare class Player {
    name: string;
    logger: any;
    config: RawConductorConfig;
    onJoin: () => void;
    onLeave: () => void;
    onSignal: ((signal: any) => void) | null;
    onActivity: () => void;
    scenarioUID: string;
    _conductor: Conductor | null;
    _adminInterfacePort?: number;
    _spawnConductor: SpawnConductorFn;
    constructor({ scenarioUID, name, config, adminInterfacePort, onJoin, onLeave, onActivity, spawnConductor }: ConstructorArgs);
    appWs: (context?: string | undefined) => AppWebsocket | TunneledAppClient;
    adminWs: (context?: string | undefined) => AdminWebsocket | TunneledAdminClient;
    /**
     * `startup` can take a function as an argument, which allows the caller
     * to do something with the child process handle, even before the conductor
     * has fully started up. Otherwise, by default, you will have to wait for
     * the proper output to be seen before this promise resolves.
     */
    startup: (spawnArgs: any) => Promise<void>;
    shutdown: (signal?: string) => Promise<boolean>;
    /** Runs at the end of a test run */
    cleanup: (signal?: string) => Promise<boolean>;
    /**
     * helper to create agent keys and install multiple apps for scenario initialization
     */
    installAgentsHapps: (agentsHapps: InstallAgentsHapps) => Promise<InstalledAgentHapps>;
    /**
     * expose registerDna at the player level for in-scenario dynamic installation of apps
     */
    registerDna: (source: T.DnaSource, ...params: any[]) => Promise<HoloHash>;
    /**
     * expose installBundledHapp at the player level for in-scenario dynamic installation of apps
     * optionally takes an AgentPubKey so that you can control who's who if you need to
     * otherwise will be a new and different agent every time you call it
     */
    installBundledHapp: (bundleSource: AppBundleSource, agentPubKey?: Buffer | undefined, installedAppId?: string | undefined) => Promise<InstalledHapp>;
    /**
     * expose _installBundledHapp at the player level for in-scenario dynamic installation of apps
     * using admin api's InstallAppBundleRequest for more detailed control
     */
    _installBundledHapp: (happ: InstallAppBundleRequest) => Promise<InstalledHapp>;
    /**
     * expose installHapp at the player level for in-scenario dynamic installation of apps
     * optionally takes an AgentPubKey so that you can control who's who if you need to
     * otherwise will be a new and different agent every time you call it
     */
    installHapp: (happ: InstallHapp, agentPubKey?: Buffer | undefined) => Promise<InstalledHapp>;
    /**
     * expose _installHapp at the player level for in-scenario dynamic installation of apps
     * using admin api's InstallAppRequest for more detailed control
     */
    _installHapp: (happ: InstallAppRequest) => Promise<InstalledHapp>;
    setSignalHandler: (handler: any) => void;
    listApps: (status: ListAppsRequest) => Promise<ListAppsResponse>;
    _conductorGuard: (context: any) => void;
}
export {};
