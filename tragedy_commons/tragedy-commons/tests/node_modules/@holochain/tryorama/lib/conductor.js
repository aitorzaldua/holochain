"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Conductor = void 0;
const colors = require('colors/safe');
const uuid_1 = require("uuid");
const logger_1 = require("./logger");
const conductor_api_1 = require("@holochain/conductor-api");
const cell_1 = require("./cell");
const trycp_1 = require("./trycp");
const fs = __importStar(require("fs"));
// probably unnecessary, but it can't hurt
// TODO: bump this gradually down to 0 until we can maybe remove it altogether
const WS_CLOSE_DELAY_FUDGE = 500;
/**
 * Representation of a running Conductor instance.
 * A [Player] spawns a conductor process locally or remotely and constructs this class accordingly.
 * Though Conductor is spawned externally, this class is responsible for establishing WebSocket
 * connections to the various interfaces to enable zome calls as well as admin and signal handling.
 */
class Conductor {
    constructor({ player, name, kill, onActivity, backend }) {
        this._appInterfacePort = null;
        this.initialize = () => __awaiter(this, void 0, void 0, function* () {
            this._onActivity();
            yield this._connectInterfaces();
        });
        this.listApps = (status) => __awaiter(this, void 0, void 0, function* () {
            return yield this.adminClient.listApps(status);
        });
        this.setSignalHandler = (onSignal) => {
            const prevOnSignal = this._onSignal;
            if (onSignal === null &&
                prevOnSignal !== null &&
                this._appInterfacePort !== null &&
                'unsubscribeAppInterfacePort' in this._backend) {
                this._backend.unsubscribeAppInterfacePort(this._appInterfacePort);
            }
            this._onSignal = onSignal;
            if (onSignal !== null &&
                prevOnSignal === null &&
                this._appInterfacePort !== null &&
                'subscribeAppInterfacePort' in this._backend) {
                this._backend.subscribeAppInterfacePort(this._appInterfacePort, signal => this._onSignal(signal));
            }
        };
        // this function registers a DNA from a given source
        this.registerDna = (source, uid, properties) => __awaiter(this, void 0, void 0, function* () {
            if ('path' in source && 'saveDnaRemote' in this._backend) {
                const contents = () => new Promise((resolve, reject) => {
                    fs.readFile(source.path, null, (err, data) => {
                        if (err) {
                            reject(err);
                        }
                        resolve(data);
                    });
                });
                const pathAfterReplacement = source.path.replace(/\//g, '');
                source = { path: yield this._backend.saveDnaRemote(pathAfterReplacement, contents) };
            }
            if ('url' in source) {
                if (!('downloadDnaRemote' in this._backend)) {
                    throw new Error('encountered URL DNA source on non-remote player');
                }
                source = { path: yield this._backend.downloadDnaRemote(source.url) };
            }
            const registerDnaReq = Object.assign(Object.assign({}, source), { uid, properties });
            return yield this.adminClient.registerDna(registerDnaReq);
        });
        // this function will install an app bundle as generated by hc app pack
        this.installBundledHapp = (bundleSource, agentPubKey, installedAppId, uid) => __awaiter(this, void 0, void 0, function* () {
            if (!agentPubKey) {
                agentPubKey = yield this.adminClient.generateAgentPubKey();
            }
            const bundleInstalledAppId = installedAppId || `app-${uuid_1.v4()}`;
            const installAppBundleReq = Object.assign(Object.assign({}, bundleSource), { installed_app_id: bundleInstalledAppId, agent_key: agentPubKey, membrane_proofs: {}, uid });
            return yield this._installBundledHapp(installAppBundleReq);
        });
        // install a hApp using the InstallAppBundleRequest struct from conductor-admin-api
        // you must create your own app_id and bundle, this is useful also if you
        // need to pass in uid, properties or membrane-proof
        this._installBundledHapp = (installAppBundleReq) => __awaiter(this, void 0, void 0, function* () {
            const installedAppResponse = yield this.adminClient.installAppBundle(installAppBundleReq);
            // must be enabled to be callable
            const enabledAppResponse = yield this.adminClient.enableApp({
                installed_app_id: installedAppResponse.installed_app_id
            });
            if (enabledAppResponse.errors.length > 0) {
                throw new Error(`Error - Failed to enable app: ${enabledAppResponse.errors}`);
            }
            return this._makeInstalledAgentHapp(enabledAppResponse.app);
        });
        // this function will auto-generate an `installed_app_id` and
        // `dna.nick` for you, to allow simplicity
        this.installHapp = (agentHapp, agentPubKey) => __awaiter(this, void 0, void 0, function* () {
            if (!agentPubKey) {
                agentPubKey = yield this.adminClient.generateAgentPubKey();
            }
            const dnaSources = agentHapp;
            const installAppReq = {
                installed_app_id: `app-${uuid_1.v4()}`,
                agent_key: agentPubKey,
                dnas: yield Promise.all(dnaSources.map((src, index) => __awaiter(this, void 0, void 0, function* () {
                    let source;
                    if (src instanceof Buffer) {
                        source = { hash: src };
                    }
                    else if (typeof src === 'string') {
                        source = { path: src };
                    }
                    else {
                        source = { url: src.url };
                    }
                    let dna = {
                        hash: yield this.registerDna(source, this._player.scenarioUID),
                        nick: `${index}${src}-${uuid_1.v4()}`
                    };
                    return dna;
                })))
            };
            return yield this._installHapp(installAppReq);
        });
        // install a hApp using the InstallAppRequest struct from conductor-admin-api
        // you must create your own app_id and dnas list, this is useful also if you
        // need to pass in properties or membrane-proof
        this._installHapp = (installAppReq) => __awaiter(this, void 0, void 0, function* () {
            yield this.adminClient.installApp(installAppReq);
            // must be enabled to be callable
            const enabledAppResponse = yield this.adminClient.enableApp({
                installed_app_id: installAppReq.installed_app_id
            });
            if (enabledAppResponse.errors.length > 0) {
                throw new Error(`Error - Failed to enable app: ${enabledAppResponse.errors}`);
            }
            return this._makeInstalledAgentHapp(enabledAppResponse.app);
        });
        this._makeInstalledAgentHapp = (installedAppResponse) => {
            const agentPubKey = installedAppResponse.cell_data[0].cell_id[1];
            const rawCells = Object.entries(installedAppResponse.cell_data);
            // construct Cell instances which are the most useful class to the client
            const cells = rawCells.map(([_, { cell_id, cell_nick }]) => new cell_1.Cell({
                cellId: cell_id,
                cellNick: cell_nick,
                player: this._player
            }));
            const installedAgentHapp = {
                hAppId: installedAppResponse.installed_app_id,
                agent: agentPubKey,
                cells,
            };
            return installedAgentHapp;
        };
        this._connectInterfaces = () => __awaiter(this, void 0, void 0, function* () {
            if (this._backend.type === 'test') {
                throw new Error('cannot call _connectInterface without a conductor backend');
            }
            this._onActivity();
            // 0 in this case means use any open port
            let appPortNumber = 0;
            if (this._backend.type === 'local') {
                const adminWsUrl = `ws://${this._backend.machineHost}:${this._backend.adminInterfacePort}`;
                this.adminClient = yield conductor_api_1.AdminWebsocket.connect(adminWsUrl);
                this.logger.debug(`connectInterfaces :: connected admin interface at ${adminWsUrl}`);
                appPortNumber = this._backend.appInterfacePort;
            }
            const { port: appInterfacePort } = yield this.adminClient.attachAppInterface({ port: appPortNumber });
            console.log('App Port spun up on port ', appInterfacePort);
            switch (this._backend.type) {
                case 'local':
                    const appWsUrl = `ws://${this._backend.machineHost}:${appInterfacePort}`;
                    this.appClient = yield conductor_api_1.AppWebsocket.connect(appWsUrl, this._timeout, signal => {
                        this._onActivity();
                        if (this._onSignal !== null) {
                            this._onSignal(signal);
                        }
                        else {
                            console.info('got signal, doing nothing with it: %o', signal);
                        }
                    });
                    this.logger.debug(`connectInterfaces :: connected app interface at ${appWsUrl}`);
                    break;
                case 'trycp':
                    const backend = this._backend;
                    yield backend.connectAppInterface(appInterfacePort);
                    this.appClient = new trycp_1.TunneledAppClient((message) => __awaiter(this, void 0, void 0, function* () {
                        const res = yield backend.appInterfaceCall(appInterfacePort, message);
                        this._onActivity();
                        return res;
                    }), () => backend.disconnectAppInterface(appInterfacePort));
                    this._appInterfacePort = appInterfacePort;
                    if (this._onSignal !== null) {
                        this._backend.subscribeAppInterfacePort(appInterfacePort, signal => this._onSignal(signal));
                    }
                    break;
                default:
                    const assertNever = this._backend;
            }
        });
        this.name = name;
        this.logger = logger_1.makeLogger(`tryorama conductor ${name}`);
        this.logger.debug('Conductor constructing');
        this.kill = (signal) => __awaiter(this, void 0, void 0, function* () {
            if (this.appClient !== null) {
                const appClient = this.appClient;
                this.appClient = null;
                yield appClient.client.close();
            }
            if (this.adminClient !== null) {
                const adminClient = this.adminClient;
                this.adminClient = null;
                yield adminClient.client.close();
            }
            this.logger.debug('Killing...');
            yield kill(signal);
        });
        switch (backend.type) {
            case 'local':
            case 'test':
                this._backend = backend;
                this.adminClient = null;
                break;
            case 'trycp':
                this._backend = backend;
                this.adminClient = new trycp_1.TunneledAdminClient((message) => __awaiter(this, void 0, void 0, function* () {
                    const res = yield backend.adminInterfaceCall(message);
                    this._onActivity();
                    return res;
                }));
                break;
            default:
                const assertNever = backend;
        }
        this.appClient = null;
        this._player = player;
        this._isInitialized = false;
        this._onActivity = onActivity;
        this._timeout = 30000;
    }
}
exports.Conductor = Conductor;
//# sourceMappingURL=conductor.js.map