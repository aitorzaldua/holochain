"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TunneledAppClient = exports.TunneledAdminClient = exports.trycpSession = void 0;
const ws_1 = __importDefault(require("ws"));
const logger_1 = __importDefault(require("./logger"));
const yaml = __importStar(require("yaml"));
const msgpack = __importStar(require("@msgpack/msgpack"));
const util_1 = require("util");
exports.trycpSession = (machineEndpoint) => __awaiter(void 0, void 0, void 0, function* () {
    const url = `ws://${machineEndpoint}`;
    const ws = new ws_1.default(url);
    ws.on("error", (e) => logger_1.default.error(`trycp client error: ${e}`));
    yield new Promise((resolve, reject) => {
        ws.once("error", reject);
        ws.once("open", () => {
            ws.removeEventListener("error", reject);
            resolve();
        });
    });
    // Pings to make sure the connection stays alive
    ws.on('pong', () => {
        setTimeout(() => ws.ping(), 30000);
    });
    ws.ping();
    const responsesAwaited = {};
    const decodeSignal = (signal) => {
        const { App: [cellId, payload] } = msgpack.decode(signal);
        const decodedPayload = msgpack.decode(payload);
        return { type: "Signal", data: { cellId, payload: decodedPayload } };
    };
    const signalSubscriptions = {};
    ws.on('message', message => {
        try {
            const decoded = msgpack.decode(Buffer.from(message));
            switch (decoded.type) {
                case 'response':
                    const { id, response } = decoded;
                    responsesAwaited[id](response);
                    break;
                case 'signal':
                    const { port, data } = decoded;
                    const signal = decodeSignal(data);
                    signalSubscriptions[port](signal);
                    break;
                default:
                    ((_) => { })(decoded);
            }
        }
        catch (e) {
            console.error('Error processing message', message, e);
        }
    });
    let nextId = 0;
    const call = (request) => __awaiter(void 0, void 0, void 0, function* () {
        const id = nextId;
        nextId++;
        const payload = msgpack.encode({
            id,
            request
        });
        const responsePromise = new Promise(resolve => (responsesAwaited[id] = resolve));
        yield new Promise(resolve => ws.send(payload, {}, resolve));
        return yield responsePromise;
    });
    const makeCall = (method) => (payload) => __awaiter(void 0, void 0, void 0, function* () {
        let params = JSON.stringify(payload);
        if (params && params.length > 300) {
            params = params.substring(0, 293) + " [snip]";
        }
        logger_1.default.debug(`trycp client request to ${url}: ${method} => ${params}`);
        const result = yield call(Object.assign({ type: method }, payload));
        logger_1.default.debug('trycp client response: %j', result);
        if (result && 0 in result && !(1 in result)) {
            return result[0];
        }
        if (result && !(0 in result) && 1 in result) {
            throw new Error(`trycp error: ${util_1.inspect(result[1])}`);
        }
        return result;
    });
    const holochainInterfaceCall = (type, args, message) => __awaiter(void 0, void 0, void 0, function* () {
        let params = JSON.stringify(Object.assign(Object.assign({}, args), { message: { type: message.type } }));
        if (params && params.length > 1000) {
            params = params.substring(0, 993) + " [snip]";
        }
        logger_1.default.debug(`trycp tunneled ${type} interface call at ${url} => ${params}`);
        const result = yield call(Object.assign(Object.assign({ type: `call_${type}_interface` }, args), { message: msgpack.encode(message) }));
        if (1 in result) {
            throw new Error(`trycp error: ${util_1.inspect(result[1])}`);
        }
        const raw_response = result[0];
        const response = msgpack.decode(raw_response);
        logger_1.default.debug(`trycp tunneled ${type} interface response: %j`, { type: response.type });
        if (response.type === "error") {
            throw new Error(`${type} call error: ${util_1.inspect(response.data)}`);
        }
        return response.data;
    });
    const savedDnas = {};
    const remoteLogLevel = process.env.REMOTE_LOG_LEVEL;
    return {
        saveDna: (id, contents) => __awaiter(void 0, void 0, void 0, function* () {
            if (!(id in savedDnas)) {
                savedDnas[id] = (() => __awaiter(void 0, void 0, void 0, function* () { return makeCall('save_dna')({ id, content: yield contents() }); }))();
            }
            return yield savedDnas[id];
        }),
        downloadDna: (url) => makeCall('download_dna')({ url }),
        configurePlayer: (id, partial_config) => {
            var _a, _b, _c, _d, _e;
            return makeCall('configure_player')({
                id,
                partial_config: yaml.stringify(Object.assign(Object.assign({}, (partial_config.db_sync_level ? { db_sync_level: partial_config.db_sync_level } : {})), { signing_service_uri: (_a = partial_config.signing_service_uri) !== null && _a !== void 0 ? _a : null, encryption_service_uri: (_b = partial_config.encryption_service_uri) !== null && _b !== void 0 ? _b : null, decryption_service_uri: (_c = partial_config.decryption_service_uri) !== null && _c !== void 0 ? _c : null, network: (_d = partial_config.network) !== null && _d !== void 0 ? _d : null, dpki: (_e = partial_config.dpki) !== null && _e !== void 0 ? _e : null }))
            });
        },
        spawn: (id) => makeCall('startup')({ id, log_level: remoteLogLevel }),
        kill: (id, signal) => makeCall('shutdown')({ id, signal }),
        reset: () => makeCall('reset')(undefined),
        adminInterfaceCall: (id, message) => holochainInterfaceCall("admin", { id }, message),
        appInterfaceCall: (port, message) => holochainInterfaceCall("app", { port }, message),
        connectAppInterface: (port) => makeCall('connect_app_interface')({ port }),
        disconnectAppInterface: (port) => makeCall('disconnect_app_interface')({ port }),
        subscribeAppInterfacePort: (port, onSignal) => {
            signalSubscriptions[port] = onSignal;
        },
        unsubscribeAppInterfacePort: (port) => {
            delete signalSubscriptions[port];
        },
        closeSession: () => __awaiter(void 0, void 0, void 0, function* () {
            const closePromise = new Promise(resolve => ws.on('close', resolve));
            ws.close();
            if (ws.readyState !== 3) {
                yield closePromise;
            }
        }),
    };
});
class TunneledAdminClient {
    constructor(adminInterfaceCall) {
        this.client = { close: () => __awaiter(this, void 0, void 0, function* () { }) };
        this.adminInterfaceCall = adminInterfaceCall;
    }
    enableApp(data) {
        return this.adminInterfaceCall({ type: 'enable_app', data });
    }
    addAgentInfo(data) {
        return this.adminInterfaceCall({ type: 'add_agent_info', data });
    }
    attachAppInterface(data) {
        return this.adminInterfaceCall({ type: 'attach_app_interface', data });
    }
    disableApp(data) {
        return this.adminInterfaceCall({ type: 'disable_app', data });
    }
    dumpState(data) {
        return this.adminInterfaceCall({ type: 'dump_state', data }).then(JSON.parse);
    }
    generateAgentPubKey() {
        return this.adminInterfaceCall({ type: 'generate_agent_pub_key' });
    }
    installApp(data) {
        return this.adminInterfaceCall({ type: 'install_app', data });
    }
    installAppBundle(data) {
        return this.adminInterfaceCall({ type: 'install_app_bundle', data });
    }
    listApps(data) {
        return this.adminInterfaceCall({ type: 'list_apps', data });
    }
    // deprecated
    listActiveApps() {
        return this.adminInterfaceCall({ type: 'list_active_apps' });
    }
    listCellIds() {
        return this.adminInterfaceCall({ type: 'list_cell_ids' });
    }
    listDnas() {
        return this.adminInterfaceCall({ type: 'list_dnas' });
    }
    registerDna(data) {
        return this.adminInterfaceCall({ type: 'register_dna', data });
    }
    requestAgentInfo(data) {
        return this.adminInterfaceCall({ type: 'request_agent_info', data });
    }
    // used to attempt to manually restart a Paused app (...therefore must have been first enabled)
    startApp(data) {
        return this.adminInterfaceCall({ type: 'start_app', data });
    }
}
exports.TunneledAdminClient = TunneledAdminClient;
class TunneledAppClient {
    constructor(appInterfaceCall, disconnectAppInterface) {
        this.appInterfaceCall = appInterfaceCall;
        this.disconnectAppInterface = disconnectAppInterface;
        this.client = { close: this.close.bind(this) };
    }
    close() {
        return this.disconnectAppInterface();
    }
    appInfo(data) {
        return this.appInterfaceCall({ type: 'app_info', data });
    }
    callZome(data) {
        data.payload = msgpack.encode(data.payload);
        return this.appInterfaceCall({ type: 'zome_call', data }).then(msgpack.decode);
    }
}
exports.TunneledAppClient = TunneledAppClient;
//# sourceMappingURL=trycp.js.map