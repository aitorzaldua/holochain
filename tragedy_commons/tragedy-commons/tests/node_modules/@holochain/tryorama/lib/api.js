"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScenarioApi = void 0;
const _ = __importStar(require("lodash"));
const fs = require('fs').promises;
const path = require('path');
const YAML = require('yaml');
const hachiko_1 = require("@holochain/hachiko");
const player_1 = require("./player");
const logger_1 = __importDefault(require("./logger"));
const util_1 = require("./util");
const config_1 = require("./config");
const env_1 = __importDefault(require("./env"));
const trycp_1 = require("./trycp");
const LOCAL_MACHINE_ID = 'local';
class ScenarioApi {
    constructor(description, orchestratorData, uid, modifiers = { singleConductor: false }) {
        this.players = (playerConfigs, startupArg = true, machineEndpoint = null, resetTrycp = true) => __awaiter(this, void 0, void 0, function* () {
            logger_1.default.debug('api.players: creating players');
            // validation
            playerConfigs.forEach((pc, i) => {
                if (!_.isFunction(pc)) {
                    throw new Error(`Config for player at index ${i} contains something other than a function. Either use Config.gen to create a seed function, or supply one manually.`);
                }
            });
            let playerBuilders;
            if (machineEndpoint === null) {
                // create all the promise *creators* which will
                // create the players
                playerBuilders = yield Promise.all(playerConfigs.map((configSeed) => __awaiter(this, void 0, void 0, function* () {
                    // use the _conductorIndex and then increment it
                    const playerName = `c${this._conductorIndex++}`;
                    // local machine
                    return yield this._createLocalPlayerBuilder(playerName, configSeed);
                })));
            }
            else {
                // connect to trycp
                const trycpClient = yield this._getTrycpClient(machineEndpoint);
                if (resetTrycp) {
                    logger_1.default.info("Resetting trycp...");
                    yield trycpClient.reset();
                }
                // keep track of it so we can send a reset() at the end of this scenario
                this._trycpClients.push(trycpClient);
                // create all the promise *creators* which will
                // create the players
                playerBuilders = yield Promise.all(playerConfigs.map((configSeed) => __awaiter(this, void 0, void 0, function* () {
                    // use the _conductorIndex and then increment it
                    const playerName = `c${this._conductorIndex++}`;
                    // trycp
                    return yield this._createTrycpPlayerBuilder(trycpClient, playerName, configSeed);
                })));
            }
            // this will throw an error if something is wrong
            // now sequentially build the players
            const players = yield util_1.promiseSerialArray(playerBuilders.map(pb => pb()));
            logger_1.default.debug('api.players: players built');
            // since this function can be called multiple times, make sure
            // to keep any existing _localPlayers while adding the new ones
            this._localPlayers = this._localPlayers.concat(players);
            // spawn/startup the players if instructed to
            if (startupArg) {
                for (const player of players) {
                    // logger.info('api.players: auto-starting-up player %s', player.name)
                    yield player.startup({});
                    // logger.info('api.players: startup complete for %s', player.name)
                }
            }
            return players;
        });
        this.shareAllNodes = (players) => __awaiter(this, void 0, void 0, function* () {
            yield Promise.all(players.map((playerToShareAbout, playerToShareAboutIdx) => __awaiter(this, void 0, void 0, function* () {
                const agentInfosToShareAbout = yield playerToShareAbout.adminWs().requestAgentInfo({ cell_id: null });
                yield Promise.all(players.map((playerToShareWith, playerToShareWithIdx) => __awaiter(this, void 0, void 0, function* () {
                    if (playerToShareAboutIdx !== playerToShareWithIdx) {
                        playerToShareWith.adminWs().addAgentInfo({ agent_infos: agentInfosToShareAbout });
                    }
                })));
            })));
        });
        this._createTrycpPlayerBuilder = (trycpClient, playerName, configSeed) => __awaiter(this, void 0, void 0, function* () {
            const configJson = this._generateConfigFromSeed({ adminInterfacePort: 0, configDir: "unused" }, playerName, configSeed);
            return () => __awaiter(this, void 0, void 0, function* () {
                // FIXME: can we get this from somewhere?
                yield trycpClient.configurePlayer(playerName, configJson);
                logger_1.default.debug('api.players: player config committed for %s', playerName);
                return new player_1.Player({
                    scenarioUID: this._uid,
                    name: playerName,
                    config: configJson,
                    spawnConductor: config_1.spawnRemote(trycpClient),
                    onJoin: () => console.log("FIXME: ignoring onJoin"),
                    onLeave: () => console.log("FIXME: ignoring onLeave"),
                    onActivity: () => this._restartTimer(),
                });
            });
        });
        this._createLocalPlayerBuilder = (playerName, configSeed) => __awaiter(this, void 0, void 0, function* () {
            return () => __awaiter(this, void 0, void 0, function* () {
                const partialConfigSeedArgs = yield config_1.localConfigSeedArgs();
                const configYaml = this._generateConfigFromSeed(partialConfigSeedArgs, playerName, configSeed);
                let { admin_interfaces, app_interfaces, environment_path: configDir } = configYaml;
                yield fs.writeFile(config_1.getConfigPath(configDir), YAML.stringify(configYaml));
                let adminInterfacePort = 0;
                if (admin_interfaces) {
                    adminInterfacePort = admin_interfaces[0].driver.port;
                }
                let appInterfacePort = 0;
                if (app_interfaces) {
                    appInterfacePort = app_interfaces[0].driver.port;
                }
                logger_1.default.debug('api.players: player config committed for %s', playerName);
                return new player_1.Player({
                    scenarioUID: this._uid,
                    name: playerName,
                    config: configYaml,
                    spawnConductor: config_1.spawnLocal(configDir, adminInterfacePort, appInterfacePort),
                    onJoin: () => console.log("FIXME: ignoring onJoin"),
                    onLeave: () => console.log("FIXME: ignoring onLeave"),
                    onActivity: () => this._restartTimer(),
                });
            });
        });
        this._generateConfigFromSeed = (partialConfigSeedArgs, playerName, configSeed) => {
            const configSeedArgs = _.assign(partialConfigSeedArgs, {
                scenarioName: this.description,
                playerName,
                uid: this._uid
            });
            logger_1.default.debug('api.players: seed args generated for %s = %j', playerName, configSeedArgs);
            const configJson = configSeed(configSeedArgs);
            logger_1.default.debug("built config: %s", JSON.stringify(configJson));
            if (!configJson.environment_path) {
                throw new Error("Generated config does not have environment_path set");
            }
            return configJson;
        };
        this._getTrycpClient = (machineEndpoint) => __awaiter(this, void 0, void 0, function* () {
            logger_1.default.debug('api.players: establishing trycp client connection to %s', machineEndpoint);
            const trycpClient = yield trycp_1.trycpSession(machineEndpoint);
            logger_1.default.debug('api.players: trycp client session established for %s', machineEndpoint);
            return trycpClient;
        });
        this._clearTimer = () => {
            logger_1.default.silly('cleared timer');
            clearTimeout(this._activityTimer);
            this._activityTimer = null;
        };
        this._restartTimer = () => {
            logger_1.default.silly('restarted timer');
            clearTimeout(this._activityTimer);
            this._activityTimer = setTimeout(() => this._destroyLocalConductors(), env_1.default.conductorTimeoutMs);
        };
        this._destroyLocalConductors = () => __awaiter(this, void 0, void 0, function* () {
            const kills = yield this._cleanup('SIGKILL');
            this._clearTimer();
            const names = this._localPlayers.filter((player, i) => kills[i]).map(player => player.name);
            names.sort();
            const msg = `
The following conductors were forcefully shutdown after ${env_1.default.conductorTimeoutMs / 1000} seconds of no activity:
${names.join(', ')}
`;
            if (env_1.default.strictConductorTimeout) {
                this.fail(msg);
                throw new Error(msg);
            }
            else {
                logger_1.default.error(msg);
            }
        });
        /**
         * Only called externally when there is a test failure,
         * to ensure that players/conductors have been properly cleaned up
         */
        this._cleanup = (signal) => __awaiter(this, void 0, void 0, function* () {
            logger_1.default.debug("Calling Api._cleanup. description: %s", this.description);
            const localKills = yield Promise.all(this._localPlayers.map(player => player.cleanup(signal)));
            yield Promise.all(this._trycpClients.map((trycp) => __awaiter(this, void 0, void 0, function* () {
                yield trycp.reset();
                yield trycp.closeSession();
            })));
            this._clearTimer();
            return localKills;
        });
        this.description = description;
        this.fail = (reason) => { throw new Error(`s.fail: ${reason}`); };
        this._localPlayers = [];
        this._trycpClients = [];
        this._uid = uid;
        this._waiter = new hachiko_1.Waiter(hachiko_1.FullSyncNetwork, undefined, orchestratorData.waiterConfig);
        this._modifiers = modifiers;
        this._activityTimer = null;
        this._conductorIndex = 0;
    }
}
exports.ScenarioApi = ScenarioApi;
//# sourceMappingURL=api.js.map