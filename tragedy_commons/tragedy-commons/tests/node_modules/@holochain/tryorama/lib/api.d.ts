import { Waiter } from '@holochain/hachiko';
import * as T from "./types";
import { Player } from "./player";
import { TrycpClient } from './trycp';
declare type Modifiers = {
    singleConductor: boolean;
};
declare type PlayerBuilder = () => Promise<Player>;
export declare class ScenarioApi {
    description: string;
    fail: Function;
    _localPlayers: Array<Player>;
    _trycpClients: Array<TrycpClient>;
    _uid: string;
    _waiter: Waiter;
    _modifiers: Modifiers;
    _activityTimer: any;
    _conductorIndex: number;
    constructor(description: string, orchestratorData: any, uid: string, modifiers?: Modifiers);
    players: (playerConfigs: Array<T.PlayerConfig>, startupArg?: boolean, machineEndpoint?: string | null, resetTrycp?: boolean) => Promise<Array<Player>>;
    shareAllNodes: (players: Array<Player>) => Promise<void>;
    _createTrycpPlayerBuilder: (trycpClient: TrycpClient, playerName: string, configSeed: T.ConfigSeed) => Promise<PlayerBuilder>;
    _createLocalPlayerBuilder: (playerName: string, configSeed: T.ConfigSeed) => Promise<PlayerBuilder>;
    _generateConfigFromSeed: (partialConfigSeedArgs: T.PartialConfigSeedArgs, playerName: string, configSeed: T.ConfigSeed) => T.RawConductorConfig;
    _getTrycpClient: (machineEndpoint: string) => Promise<TrycpClient>;
    _clearTimer: () => void;
    _restartTimer: () => void;
    _destroyLocalConductors: () => Promise<void>;
    /**
     * Only called externally when there is a test failure,
     * to ensure that players/conductors have been properly cleaned up
     */
    _cleanup: (signal?: any) => Promise<Array<boolean>>;
}
export {};
