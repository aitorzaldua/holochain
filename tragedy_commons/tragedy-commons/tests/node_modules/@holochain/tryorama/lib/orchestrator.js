"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Orchestrator = void 0;
const uuid_1 = require("uuid");
const _ = __importStar(require("lodash"));
const M = __importStar(require("./middleware"));
const R = __importStar(require("./reporter"));
const logger_1 = __importDefault(require("./logger"));
const api_1 = require("./api");
const defaultModeOpts = {
    executor: { tape: require('tape') },
    spawning: 'local',
};
const modeToMiddleware = (mode) => {
    const executor = (mode.executor === 'none')
        ? M.runSeries()
        : mode.executor === 'tape'
            ? M.tapeExecutor(require('tape'))
            : M.tapeExecutor(mode.executor.tape);
    return M.compose(executor, M.localOnly);
};
class Orchestrator {
    constructor(o = {}) {
        this.numRegistered = () => this._scenarios.length;
        this.run = () => __awaiter(this, void 0, void 0, function* () {
            const allTests = this._scenarios;
            const onlyTests = allTests.filter(({ modifier }) => modifier === 'only');
            const tests = onlyTests.length > 0
                ? onlyTests
                : allTests.filter(({ modifier }) => modifier !== 'skip');
            this._reporter.before(tests.length);
            logger_1.default.debug("About to execute %d tests", tests.length);
            if (onlyTests.length > 0) {
                logger_1.default.warn(`.only was invoked; only running ${onlyTests.length} test(s)!`);
            }
            if (tests.length < allTests.length) {
                logger_1.default.warn(`Skipping ${allTests.length - tests.length} test(s)!`);
            }
            return this._executeSeries(tests);
        });
        this._executeParallel = (tests) => __awaiter(this, void 0, void 0, function* () {
            let successes = 0;
            const errors = [];
            const all = tests.map(({ api, desc, execute }) => {
                return { api, desc, promise: execute() };
            }).map(({ api, desc, promise }) => {
                return promise
                    .then(() => {
                    console.debug('success for ', desc);
                    successes += 1;
                })
                    .catch(e => {
                    console.error(`got an error for test '${desc}':`, e);
                    errors.push({ description: desc, error: e });
                })
                    .then(api._cleanup)
                    .then(() => logger_1.default.debug("Done with _cleanup"));
            });
            yield Promise.all(all);
            const stats = { successes, errors };
            this._reporter.after(stats);
            return stats;
        });
        // The call serial middleware doesn't work because it starts the next test before cleaning up the previous
        this._executeSeries = (tests) => __awaiter(this, void 0, void 0, function* () {
            let successes = 0;
            const errors = [];
            for (const { api, desc, execute } of tests) {
                this._reporter.each(desc);
                try {
                    logger_1.default.debug("Executing test: %s", desc);
                    yield execute();
                    logger_1.default.debug("Test succeeded: %s", desc);
                    successes += 1;
                }
                catch (e) {
                    logger_1.default.debug("Test failed: %s %o", desc, e);
                    errors.push({ description: desc, error: e });
                }
                finally {
                    logger_1.default.debug("Cleaning up test: %s", desc);
                    yield api._cleanup();
                    logger_1.default.debug("Finished with test: %s", desc);
                }
            }
            const stats = {
                successes,
                errors
            };
            this._reporter.after(stats);
            return stats;
        });
        this._registerScenario = (desc, scenario, modifier) => {
            const orchestratorData = _.pick(this, [
                '_globalConfig',
                'waiterConfig',
            ]);
            const api = new api_1.ScenarioApi(desc, orchestratorData, uuid_1.v4());
            const runner = scenario => scenario(api);
            const execute = () => this._middleware(runner, scenario);
            this._scenarios.push({ api, desc, execute, modifier });
        };
        if (o.mode && o.middleware) {
            throw new Error("Cannot set both `mode` and `middleware` in the orchestrator params. Pick one or the others.");
        }
        this._middleware = o.middleware || modeToMiddleware(o.mode || defaultModeOpts);
        this._scenarios = [];
        this._reporter = o.reporter === true
            ? R.basic(x => console.log(x))
            : o.reporter || R.unit;
        this.waiterConfig = o.waiter;
        const registerScenario = (desc, scenario) => this._registerScenario(desc, scenario, null);
        const registerScenarioOnly = (desc, scenario) => this._registerScenario(desc, scenario, 'only');
        const registerScenarioSkip = (desc, scenario) => this._registerScenario(desc, scenario, 'skip');
        this.registerScenario = Object.assign(registerScenario, {
            only: registerScenarioOnly,
            skip: registerScenarioSkip,
        });
    }
}
exports.Orchestrator = Orchestrator;
//# sourceMappingURL=orchestrator.js.map