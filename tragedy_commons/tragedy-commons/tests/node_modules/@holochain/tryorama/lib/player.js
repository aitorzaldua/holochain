"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Player = void 0;
const logger_1 = require("./logger");
const get_port_cautiously_1 = require("./config/get-port-cautiously");
const fs = require('fs').promises;
/**
 * Representation of a Conductor user.
 * A Player is essentially a wrapper around a conductor config that was generated,
 * and the possible reference to a conductor which is running based on that config.
 * The Player can spawn or kill a conductor based on the generated config.
 * Players are the main interface for writing scenarios.
 */
class Player {
    constructor({ scenarioUID, name, config, adminInterfacePort, onJoin, onLeave, onActivity, spawnConductor }) {
        this.onSignal = null;
        this.appWs = (context) => {
            this._conductorGuard(context || `Player.appWs()`);
            return this._conductor.appClient;
        };
        this.adminWs = (context) => {
            this._conductorGuard(context || `Player.adminWs()`);
            return this._conductor.adminClient;
        };
        /**
         * `startup` can take a function as an argument, which allows the caller
         * to do something with the child process handle, even before the conductor
         * has fully started up. Otherwise, by default, you will have to wait for
         * the proper output to be seen before this promise resolves.
         */
        this.startup = (spawnArgs) => __awaiter(this, void 0, void 0, function* () {
            if (this._conductor) {
                this.logger.warn(`Attempted to start up conductor '${this.name}' twice!`);
                return;
            }
            this.onJoin();
            this.logger.debug("starting up");
            const conductor = yield this._spawnConductor(this, spawnArgs);
            this.logger.debug("started up");
            this._conductor = conductor;
            this.logger.debug("initializing");
            yield this._conductor.initialize();
            this.logger.debug("initialized");
        });
        this.shutdown = (signal = 'SIGTERM') => __awaiter(this, void 0, void 0, function* () {
            if (this._conductor) {
                const c = this._conductor;
                this._conductor = null;
                this.logger.debug("Shutting down...");
                yield c.kill(signal);
                this.logger.debug("Shut down.");
                this.onLeave();
                return true;
            }
            else {
                this.logger.warn(`Attempted to shut down conductor '${this.name}' twice`);
                return false;
            }
        });
        /** Runs at the end of a test run */
        this.cleanup = (signal = 'SIGTERM') => __awaiter(this, void 0, void 0, function* () {
            this.setSignalHandler(null);
            this.logger.debug("calling Player.cleanup, conductor: %b", this._conductor);
            if (this._conductor) {
                yield this.shutdown(signal);
                if (this._adminInterfacePort !== undefined) {
                    get_port_cautiously_1.unparkPort(this._adminInterfacePort);
                }
            }
            if (this._adminInterfacePort !== undefined) {
                get_port_cautiously_1.unparkPort(this._adminInterfacePort);
            }
            return this._conductor !== null;
        });
        /**
         * helper to create agent keys and install multiple apps for scenario initialization
         */
        this.installAgentsHapps = (agentsHapps) => {
            this._conductorGuard(`Player.installHapps`);
            return Promise.all(agentsHapps.map((agentHapps) => __awaiter(this, void 0, void 0, function* () {
                // for each agent, create one key and install all the happs under that key
                const agentPubKey = yield this.adminWs().generateAgentPubKey();
                return Promise.all(agentHapps.map(happ => this.installHapp(happ, agentPubKey)));
            })));
        };
        /**
         * expose registerDna at the player level for in-scenario dynamic installation of apps
         */
        this.registerDna = (source, ...params) => __awaiter(this, void 0, void 0, function* () {
            this._conductorGuard(`Player.registerDna(source ${JSON.stringify(source)}, params ${JSON.stringify(params)})`);
            return this._conductor.registerDna(source, ...params);
        });
        /**
         * expose installBundledHapp at the player level for in-scenario dynamic installation of apps
         * optionally takes an AgentPubKey so that you can control who's who if you need to
         * otherwise will be a new and different agent every time you call it
         */
        this.installBundledHapp = (bundleSource, agentPubKey, installedAppId) => __awaiter(this, void 0, void 0, function* () {
            this._conductorGuard(`Player.installBundledHapp(${JSON.stringify(bundleSource)}, ${agentPubKey ? 'withAgentPubKey' : 'noAgentPubKey'}, ${installedAppId || 'noInstalledAppId'})`);
            return this._conductor.installBundledHapp(bundleSource, agentPubKey, installedAppId);
        });
        /**
         * expose _installBundledHapp at the player level for in-scenario dynamic installation of apps
         * using admin api's InstallAppBundleRequest for more detailed control
         */
        this._installBundledHapp = (happ) => __awaiter(this, void 0, void 0, function* () {
            this._conductorGuard(`Player._installHapp(${JSON.stringify(happ)})`);
            return this._conductor._installBundledHapp(happ);
        });
        /**
         * expose installHapp at the player level for in-scenario dynamic installation of apps
         * optionally takes an AgentPubKey so that you can control who's who if you need to
         * otherwise will be a new and different agent every time you call it
         */
        this.installHapp = (happ, agentPubKey) => __awaiter(this, void 0, void 0, function* () {
            this._conductorGuard(`Player.installHapp(${JSON.stringify(happ)}, ${agentPubKey ? 'noAgentPubKey' : 'withAgentPubKey'})`);
            return this._conductor.installHapp(happ, agentPubKey);
        });
        /**
         * expose _installHapp at the player level for in-scenario dynamic installation of apps
         * using admin api's InstallAppRequest for more detailed control
         */
        this._installHapp = (happ) => __awaiter(this, void 0, void 0, function* () {
            this._conductorGuard(`Player._installHapp(${JSON.stringify(happ)})`);
            return this._conductor._installHapp(happ);
        });
        this.setSignalHandler = (handler) => {
            this.onSignal = handler;
            if (this._conductor) {
                this._conductor.setSignalHandler(handler);
            }
        };
        this.listApps = (status) => __awaiter(this, void 0, void 0, function* () {
            this._conductorGuard(`Player.listApps(${JSON.stringify(status)})`);
            return this._conductor.listApps(status);
        });
        this._conductorGuard = (context) => {
            if (this._conductor === null) {
                const msg = `Attempted conductor action when no conductor is running! You must \`.startup()\` first.\nAction: ${context}`;
                this.logger.error(msg);
                throw new Error(msg);
            }
            else {
                this.logger.debug(context);
            }
        };
        this.name = name;
        this.logger = logger_1.makeLogger(`player ${name}`);
        this.onJoin = onJoin;
        this.onLeave = onLeave;
        this.onActivity = onActivity;
        this.config = config;
        this.scenarioUID = scenarioUID,
            this._conductor = null;
        this._adminInterfacePort = adminInterfacePort;
        this._spawnConductor = spawnConductor;
    }
}
exports.Player = Player;
//# sourceMappingURL=player.js.map